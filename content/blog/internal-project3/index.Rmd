---
title: 'Classification: Predicting Wheat Variety Using Ensemble Models'
author: "Prithviraj Lakkakula"
date: "2022-04-16T00:00:00Z"
external_link: ""
summary: Predict wheat variety accurately using multiple features employing two popular ensemble models, including random forest and gradient boosting model accounting for multicollinearity and hyperparameter tuning.
tags:
- classification
- random forest
- gradient boosting
- model evaluation
output: 
  html_document: 
    toc: yes
    highlight: zenburn
    theme: cerulean
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kernlab)
```

```{r, include=FALSE}
options(tinytex.verbose = TRUE)
```

```{r include=FALSE}
#include=FALSE #Won't output this chunk of r code and results in final output
#echo=FALSE #prevents code, but not the results from appearing in the finished file
#warning = FALSE #wont display warning messages in the finished file
#message = FALSE # prevents warnings that are generated by code from apparing in the finshed file
#fig.cap = "..." #adds a caption to graphical results.

```

## Goal

The project's goal is to accurately predict the wheat variety (`Kama`, `Rosa`, `Canadian`) using the attributes corresponding to each of the wheat variety. Additionally, it will be interesting to know which of the features play an important role in predicting the accurate wheat variety. 

## Data

In this project, I classify wheat variety based on the wheat kernel's geometrical properties. There are three varieties of wheat (`Kama`, `Rosa`, and `Canadian`), which is the categorical variable. Each variety has 70 observations accounting for a total of 210 observations. There are seven features (X), including area, perimeter, compactness, length of the kernel, width of the kernel, asymmetry coefficient, and length of kernel groove. Data are collected from UC Irvine Machine Learning Repository at <https://archive-beta.ics.uci.edu/ml/datasets/seeds>.

## Data Preprocessing

```{r message = FALSE, warning=FALSE}
library(dplyr)
wht_data <- read.csv("wheat_var_data.csv")
glimpse(wht_data)
```

```{r message=FALSE, warning=FALSE}
summary(wht_data)
```

By inspecting mean and median of all seven attributes, one can conclude that there are no outliers/anomalies. Also, we need to convert the `wheat_variety` variable into categorical or qualitative or class variable instead of an integer.

```{r message=FALSE, warning=FALSE}
library(dplyr)
wht_data$wheat_variety <- as.factor(wht_data$wheat_variety)
wht_data <- wht_data %>%
  mutate(wheat_var = 
           ifelse(wheat_variety == "1", "Kama",      
                  ifelse(wheat_variety == "2", "Rosa", "Canadian"))) %>%
  select(-wheat_variety)
str(wht_data)
```

## Exploratory Data Analysis

Let us now look at the relationships of the three wheat varieties with each of the seven features.

```{r message=FALSE, warning=FALSE}
library(dplyr)
wht_data %>%
  group_by(wheat_var) %>%
  summarise_all(mean)
```

On average, `Rosa` wheat variety seem to have higher length, width, area, perimeter and compactness, followed by `Kama` variety. However, `Canadian` variety has the highest average asymmetry coefficient compared with other wheat varieties.


```{r fig.cap="Density plot of kernel length of three wheat varieties", message=FALSE}
library(ggplot2)
library(geomtextpath)

ggplot(wht_data, aes(x = length_kernel, colour = wheat_var, label = wheat_var)) +
  geom_textdensity(size = 6, fontface = 2, hjust = 0.2, vjust = 0.3) +
  theme(legend.position = "none") + theme_bw()
```

```{r fig.cap="Density plot of asymmetry coefficient of three wheat varieties"}
library(ggplot2)
library(geomtextpath)
ggplot(wht_data, aes(x = asymmetry_coef, colour = wheat_var, 
                     label = wheat_var)) +
       theme(legend.position = "none") +
       geom_textdensity(size = 6, fontface = 2, spacing = 50,
                   vjust = -0.2, hjust = "ymax") + ylim(c(0, 0.4)) + theme_minimal()
```


```{r, fig.cap= 'Trend Lines through scatter plot of length and width of wheat varieties'}
ggplot(wht_data, aes(x = length_kernel, y = width_kernel, 
                     color = wheat_var)) +
  geom_point(alpha = 0.3) + theme(legend.position = "bottom") +
  geom_labelsmooth(aes(label = wheat_var), text_smoothing = 30, 
                   fill = "#F6F6FF",
                method = "loess", formula = y ~ x,
                size = 4, linewidth = 1, boxlinewidth = 0.3) +
  scale_colour_manual(values = c("forestgreen", "deepskyblue4", "tomato4")) +
   theme_bw()
```

### Correlation Pairs

The correlation plot shown below reveal that there is multicollinearity problem. To deal with multicollinearity, there are a couple of solutions, including 1) removing one of the features from the highly correlated feature combinations, 2) linearly combine the variables using principal component analysis or partial least squares. In this case, I will use the first option to remove `perimeter`, `length_kernel`, and `width_kernel` features.

```{r message=FALSE, warning=FALSE}
library(psych)
pairs.panels(wht_data)
```

The correlation pairs plot after removing the above mentioned features is shown below.

```{r message=FALSE, warning=FALSE}
library(psych)
library(tidyverse)
wht_data <- wht_data %>%
  select(!c(perimeter, length_kernel, width_kernel))

pairs.panels(wht_data)
```

<!--
### Range
Now, let us look at the range of all the variables except the response variable.

```{r message=FALSE, warning=FALSE}
wht_data %>%
  select(-wheat_var) %>%
  summarise_all(range)
```

## Standardization of the features

Since some of the variables are in different range than the others. Let us do Z-score normalization or standardization the `scale()` function in R. When applying the decision trees (random forests and gradient boosting) and KNN machine learning algorithms, we may need not scale.

#```{r message=FALSE, warning=FALSE}
##library(dplyr)
##Z-score normalization
##wht_data_scaled <- wht_data %>% mutate_each_(list(~scale(.) %>% as.vector),
##vars = c("area","perimeter", "compactness", 
##         "length_kernel", "width_kernel", 
##         "asymmetry_coef", "length_kernel_groove"))
##head(wht_data_scaled)
#```
-->

### Near-zero variance features

```{r message=FALSE, warning=FALSE}
library(caret)
near_0_var <- nearZeroVar(wht_data, names = TRUE)
print(near_0_var)
```

The result indicate that there are no zero variance features, which is good. Therefore, we can use all the features to predict the the class of wheat variety.

### Checking for class imbalance

It was already known that there are equal observations for each of the wheat varieties in our dataset. That is, each variety has 70 observations for a total of 210 observations. Therefore, our data set do not suffer with class imbalance problem.

```{r message=FALSE, warning=FALSE}
table(wht_data$wheat_var)
```

## Ensemble Models

### Splitting the data

```{r message=FALSE, warning=FALSE}
library(caret)

set.seed(4321)
wht_data$wheat_var <- as.factor(wht_data$wheat_var)
in_train <- createDataPartition(y = wht_data$wheat_var, 
                                p = 0.80, list = FALSE)

training <- wht_data[in_train,]
testing <- wht_data[-in_train,]

table(training$wheat_var)
table(testing$wheat_var)
head(training)
str(training)
```



### Hyperparameter Tuning
In the case of Random Forest model, number of features selected in `mtry` for constructing decision trees (or more specifically at each split) is probably the most important tuning parameter. 

#### Random Search for Randomly Selecting Predictors (mtry)
```{r message=FALSE, warning=FALSE}
#modelLookup("rf")

library(caret)

fitControl <- trainControl(method = "repeatedcv",
                            number = 5, repeats = 5,
                           search = 'random')

#manual_grid_rf <- expand.grid(#n.trees = c(100, 200, 500, 750, 1000),
#                         #interaction.depth = c(1, 4, 6),
#                         #shrinkage = 0.1,
#                         #n.minobsinnode = 10,
#                         .mtry = c(1:5))
set.seed(143)
library(tictoc)
tic()

model_rf_random <- train(wheat_var ~.,
                         data = training,
                         method = "rf",
                         metric = 'Accuracy',
                         trControl = fitControl,
                         verbose = FALSE,
                         tuneLength = 4)
toc()
print(model_rf_random)
plot(model_rf_random)
```

#### Grid Search for Selecting Optimal mtry
```{r}
fitControl <- trainControl(method = "repeatedcv",
                            number = 3, repeats = 5,
                           search = 'grid')

tunegrid <- expand.grid(.mtry = (1:4)) 

model_rf_grid <- train(wheat_var ~.,
                       data = training,
                       method = 'rf',
                       metric = 'Accuracy',
                       tuneGrid = tunegrid)
print(model_rf_grid)
plot(model_rf_grid)
```

The grid search and random search suggest same `mtry` values in this case. Generally, grid search is considered as accurate as it evaluates all the combinations in the proposed Cartesian grid. Therefore, for modeling random forest model, `mtry = 1` was used for the final model (shown later).


```{r message=FALSE, warning=FALSE}
library(caret)
manual_grid <- expand.grid(n.trees = c(100, 200, 500),
                         interaction.depth = c(1, 4, 6),
                         shrinkage = 0.1,
                         n.minobsinnode = 10)

fitControl <- trainControl(method = "repeatedcv",
                            number = 3, repeats = 5)
library(tictoc)
tic()
set.seed(123)
model_gbm_grid <- train(wheat_var ~.,
                         data = training,
                         method = "gbm",
                         trControl = fitControl,
                         verbose = FALSE,
                         tuneGrid = manual_grid)
toc()
plot(model_gbm_grid)
plot(model_gbm_grid,
     metric = "Kappa",
     plotType = "level")
```

The plots of gradient boosting model reveal that maximum accuracy is achieved when the number of trees are set at 100 with the tree depth (interaction.depth) at 4.

### Classification: Random Forest

```{r message=FALSE, warning=FALSE}
### load the randomForest package
library(randomForest)
set.seed(123)
### train the random forest model: model_rf
model_rf <- randomForest(formula = wheat_var ~.,
                         data = training,
                         ntree = 300,
                         mtry = 1)

### print the rf model
print(model_rf)

### variable importance plots
varImpPlot(model_rf)
print(model_rf$importance)
```

### Classification : Gradient Boosting Model

```{r message=FALSE, warning=FALSE}
### load the gradient boosting model package
library(gbm)
set.seed(143)
### train the gradient boosting model: model_gbm
model_gbm <- gbm(formula = wheat_var ~.,
                         data = training,
                         n.trees = 100,
                         interaction.depth = 4,
                         shrinkage = 0.1,
                         n.minobsinnode = 10)

### print the gbm model
print(model_gbm)

### summarize gbm's variable importance plots
summary(model_gbm)
```

### Evaluating both Random Forest and Gradient Boosting Algorithms

```{r message=FALSE, warning=FALSE}
library(Metrics)

preds_rf <- predict(model_rf, newdata = testing)
preds_gbm <- predict(model_gbm, n.trees = 100, newdata = testing, type = "response")
## compute confusion matrix



classes <- colnames(preds_gbm)[apply(preds_gbm, 1, which.max)]
result_gbm <- data.frame(testing$wheat_var, classes)

#print(result_gbm)
(cm_rf <- confusionMatrix(preds_rf, testing$wheat_var))
(cm_gbm <- confusionMatrix(as.factor(classes), testing$wheat_var))

```

## Conclusions
The ensemble models suggest that there is an accuracy of about 93% in case of both Random Forest and GBM predicting the correct wheat variety using a set of features. Variable importance plot results of both the models show that area (highest importantance), length of kernel groove, asymmetry coefficient, and compactness (lowest importance) play an important role in wheat variety prediction. in case of both the models. Overall, both the models show consistent results and agree with each other. 

In the UC Irvine's data repository, it was indicated that there was some critical features that they could not provide due to proprietary issues associated with those data. Therefore, given those additional features, there is a scope for improving accuracy rate. Overall, the classification results show that accuracy of predicting the correct wheat variety is high. 

<!--
### Training Ensemble Models
```{r}
library(caret)
library(caretEnsemble)
## Let us create a 5-fold cross valiadtion training control object
train_control <- trainControl(method = "cv",
                              number = 5,
                              savePredictions = TRUE,
                              classProbs = TRUE)

## create a vector of base learners
base_learners <- c('rpart', 'knn', 'svmRadial')

## create and summarize the list of base learners
all_models <- caretList(wheat_var ~ .,
                        data = training,
                        trControl = train_control,
                        methodList = base_learners)
summary(all_models)
```
-->

